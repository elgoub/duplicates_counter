// React Componentsvar OutputBox = React.createClass({  getInitialState: function() {    return {      errors: [],      result: [],      keywords: ['leo', 'eu', 'ipsum', 'dummy', 'elit', 'pharetra', 'sociis'],      newDescription: 'Lorem ipsum dolor sit amet, consectetur adipiscing elit. Morbi vel eleifend massa. Donec iaculis ipsum eu ultricies dictum.\nNullam vitae odio in nisi mollis condimentum a eu lacus.\nUt eget vestibulum sapien.\nPellentesque libero ex, tristique ac pellentesque nec, fermentum sit amet nulla.\nNulla facilisi. Duis a massa leo. Etiam ut nisl nec leo pharetra lobortis.\nIn lectus libero, molestie in lacus ac, tincidunt dapibus enim. Cras ligula nunc, commodo vitae ligula a, posuere vulputate leo.\nCum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Ut turpis sem, elementum sit amet sapien a, facilisis interdum nibh.\n\nNam sit amet lectus at ex blandit ornare.',      currentDescription: ''    };  },  count: function(keywords, newDescription, currentDescription) {    var result = _.map(keywords, function(keyword) {      var re           = new RegExp(keyword, 'g');      var newCount     = (newDescription.match(re)||[]).length;      var currentCount = (currentDescription.match(re)||[]).length;      return {keyword: keyword, newCount: newCount, currentCount: currentCount};    })||[];     return _.sortBy(result, 'newCount').reverse();  },  componentDidMount: function() {    var form = document.getElementById('form');    var that = this;    form.addEventListener('submit', function(e) {      e.preventDefault();            var keywords           = form['keywords'].value;      var newDescription     = form['description1'].value;      var currentDescription = form['description2'].value;      var errors = [], result = [];      if (keywords == null || keywords.length == 0) {          errors.push('Keywords are required.');      }      if (newDescription == null || newDescription.length == 0) {          errors.push('New description is required.');      }      // Count duplicated keywords      if (errors.length == 0) {        var array = keywords.trim().split(',');        result = that.count(array, newDescription, currentDescription||'');      }      that.setState({errors: errors, result: result, description: newDescription});    }, false);    this.setState({result: this.count(this.state.keywords, this.state.newDescription, this.state.currentDescription)});  },  render: function() {    return (      <div className="output-box">        <h1>Output</h1>        <ErrorBox errors={this.state.errors}/>        <Result result={this.state.result} description={this.state.newDescription}/>      </div>    );  }});var ErrorBox = React.createClass({  render: function() {    var errorNodes = this.props.errors.map(function (error) {      return (        <p>          {error}        </p>      );    });    return (      <div className="error">        {errorNodes}      </div>    );  }});var Result = React.createClass({  makeColoredDescription: function() {    var description = this.props.description;    _.map(this.props.result, function(result) {      var re    = new RegExp(result.keyword, 'gi');      description = description.replace(re, function(matched) {          return "<span style='color:red'>" + matched + "</span>";      });    });    var elm = '<div>' + description + '</div>';    elm = elm.replace(/\r?\n/g, '<br />');    return  { __html: elm };  },  render: function() {    var width = window.innerWidth    || document.documentElement.clientWidth    || document.body.clientWidth;    if (width < 1000) {      width = 1000;    }    width -= 450;    var keywordsNodes = this.props.result.map(function (data) {      return (        <span>          {data.keyword + ': ' + data.newCount + ', '}        </span>      );    });    document.getElementById('output').style.width = width + 'px';     return (      <div>        <canvas id="chart" width={width} height="500"></canvas>        <ul id="legend" className="chart-legend"/>        <div className="output-texts">          <p>Description:</p>          <div className="output-description" dangerouslySetInnerHTML={this.makeColoredDescription()} />          <p>Keywords:</p>          <div className="output-keywords">            {keywordsNodes}          </div>        </div>      </div>    );  },  componentDidMount: function() {    this.componentDidUpdate();  },  componentDidUpdate: function(prevProps, prevState) {    var elm  = document.getElementById('chart');    var ctx  = elm.getContext('2d');    if (ctx == null) {      return;    }    var data = {        labels: _.pluck(this.props.result, 'keyword'),        datasets: [            {                label: "New description",                fillColor: "rgba(247, 70, 74, 0.6)",                strokeColor: "rgba(247, 70, 74, 0.8)",                pointColor: "rgba(247, 70, 74, 0.8)",                pointStrokeColor: "rgba(247, 70, 74, 1.0)",                pointHighlightFill: "rgba(247, 70, 74, 1.0)",                pointHighlightStroke: "rgba(220,220,220,1)",                data: _.pluck(this.props.result, 'newCount')            },            {                label: "Current description",                fillColor: "rgba(151,187,205,0.2)",                strokeColor: "rgba(151,187,205,1)",                pointColor: "rgba(151,187,205,1)",                pointStrokeColor: "#fff",                pointHighlightFill: "#fff",                pointHighlightStroke: "rgba(151,187,205,1)",                data: _.pluck(this.props.result, 'currentCount')            }        ]    };    var options = {      legendTemplate : "<% for (var i=0; i<datasets.length; i++){%><li><span style=\"color:<%=datasets[i].strokeColor%>\">â– </span><%if(datasets[i].label){%><%=datasets[i].label%><%}%></li><%}%>",      scaleOverride : true,      scaleSteps : (this.props.result[0]) ? this.props.result[0].newCount : 0,      scaleStepWidth : 1,      scaleStartValue : 0,      animation : true,      scaleLabel : '<%=value%>',      showTooltips: false,      pointDot : true,      bezierCurve : false    };    var chart  = new Chart(ctx).Line(data, options);    var legend = chart.generateLegend();    var legendElm = document.getElementById('legend');    legendElm.innerHTML = legend;    legendElm.style.visibility = 'visible';    legendElm.style.left = (parseInt(elm.style.width) - 175) + 'px';    legendElm.style.top  = (-parseInt(elm.style.height) + 30) + 'px';    if (this.props.result.length == 0) {      legendElm.style.visibility = 'hidden';    }  }});// RenderingReact.render(  <OutputBox />,  document.getElementById('output'));